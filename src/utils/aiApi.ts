interface GenerateCodePayload {
  prompt: string;
  conversationHistory: Array<{ role: string; content: string; image?: string }>;
  image?: string;
}

interface GenerateCodeResponse {
  code: string;
  type: 'html' | 'react';
  title: string;
  description: string;
}

/* Environment variables (set in .env) */
const OLLAMA_BASE_URL = import.meta.env.VITE_OLLAMA_API_URL; // e.g., http://localhost:11434
const OLLAMA_API_KEY = import.meta.env.VITE_OLLAMA_API_KEY || 'anything'; // any nonâ€‘empty key

if (!OLLAMA_BASE_URL) {
  throw new Error(
    "VITE_OLLAMA_API_URL must be defined in your .env (e.g., http://localhost:11434)."
  );
}

/* Build the full endpoint: base URL + '/v1/chat/completions' (no double slash) */
const OLLAMA_ENDPOINT = `${OLLAMA_BASE_URL.replace(/\/+$/g, '')}/v1/chat/completions`;

export const generateCode = async (
  payload: GenerateCodePayload,
): Promise<GenerateCodeResponse> => {
  // ðŸ‘‰ Debug: show the exact URL being called
  console.log('ðŸ“¡ Calling Ollama endpoint:', OLLAMA_ENDPOINT);

  const systemPrompt = `You are Cortex, an expert code generation AI. Generate complete, productionâ€‘ready code based on user requests.

CRITICAL RULES:
1. Output ONLY executable code (HTML, CSS, JavaScript, or a React component).
2. For simple UIs generate a full HTML file with inline CSS/JS.
3. For complex apps generate a React component **without any import/export statements**.
4. Include EVERY line of code â€“ no placeholders or comments like "// â€¦".
5. The code must run directly in a browser iframe.
6. Ensure responsive design and modern styling.
7. Use Tailwind CSS classes whenever possible.
8. Make it beautiful and functional.

NO MODULE SYNTAX:
- Do NOT use "import" or "export".
- React is globally available; just define the component function.

OUTPUT FORMAT:
Return ONLY a JSON object:
{
  "type": "html" | "react",
  "code": "complete executable code here",
  "title": "brief title",
  "description": "oneâ€‘sentence description"
}`;

  const messages = [
    { role: 'system', content: systemPrompt },
    ...(payload.conversationHistory || []).map((msg) => ({
      role: msg.role,
      content: msg.content,
    })),
    { role: 'user', content: payload.prompt },
  ];

  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${OLLAMA_API_KEY}`,
  };

  try {
    const response = await fetch(OLLAMA_ENDPOINT, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        model: 'qwen2.5-coder:7b',
        messages,
        stream: false,
      }),
    });

    if (!response.ok) {
      const err = await response.text();
      console.error('AI API error:', response.status, err);
      throw new Error(`AI API error: ${response.status} - ${err}`);
    }

    const data = await response.json();
    const content = data.message?.content;

    if (!content) {
      throw new Error('AI API returned empty content.');
    }

    // Extract JSON if itâ€™s wrapped in markdown fences
    let jsonString = content;
    const match = content.match(/```(?:json)?\s*({[\s\S]*})\s*```/);
    if (match) jsonString = match[1];

    let parsed: GenerateCodeResponse;
    try {
      parsed = JSON.parse(jsonString);
    } catch (e) {
      console.error('Failed to parse JSON from AI response:', jsonString);
      // Fallback: treat the whole response as raw HTML/React code
      parsed = {
        type: 'html',
        code: content,
        title: 'Generated Content',
        description: 'Result generated by Ollama',
      };
    }

    return parsed;
  } catch (err: any) {
    console.error('generateCode error:', err);
    throw err;
  }
};